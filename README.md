# p2p_Chat-FileTransfer
server and client file on Linux

## 1. 구현 목표
>![1](https://user-images.githubusercontent.com/82483513/119311982-ba3eb280-bcac-11eb-9413-cc7c8d733099.jpg)

## 2. 설계 조건
>(1) User1과 User2는 서버에 접속할 때, 로그인을 성공하면 자신의 P2P IP주소/Port번호 정보를 서버로 전송해준다.  
>(2) User1은 P2P 파일전송을 요청하는 특수한 메시지(“[FILE-사용자이름]”)를 키보드로부터입력받으면 서버로 전송하고 P2P 파일 송수신을 위한 P2P 파일전송 서버를 생성한다.(hint. “[FILE-사용자이름]” 을 송신하고 fork() 시스템콜을 이용하여 P2P 파일전송 서버를 위한 프로세스 생성)  
>(3) 서버는 요청한 사용자이름에 해당하는 클라이언트의 P2P IP주소/Port번호 정보와 함께“[FILE]” 메시지를 해당 사용자에 전송한다.  
>(4) “[FILE]” 를 수신한 User2는 P2P 파일전송 클라이언트가 되어 수신한 P2P IP주소/Port번호로 User1에 접속한다. (hint. “[FILE]” 메시지를 수신하면 User2s느 fork() 시스템 콜을이용하여 자식프로세스가 P2P 파일전송 클라이언트 역할을 담당하도록 함)  
>(5) P2P 파일전송 서버-클라이언트 연결이 성공적으로 생성되면 클라이언트인 User2는 자신이 소유한 파일리스트를 User1에 서버를 거치지 않고 전송한다.  
>(6) User1은 P2P 서버-클라이언트 통신으로 수신한 파일리스트를 화면에 출력해주고 전송받을 파일을 User1이 선택하여 User2에 요청한다.  
>(7) User2는 파일요청을 수신하면 해당파일을 읽어 메시지로 만들어 User1에 전송해준다.  
>(8) User1은 수신한 메시지로 다시 해당파일 이름으로 파일을 생성하여 저장함으로써 User2에 성공적으로 수신한 파일이 생성되도록 한다.  

## 3. 구현 도중 발생한 문제점
>1. 로그인 성공시 서버에서 접속한 아이피주소와 포트번호를 저장시키는데 문제가 계속 발생하였다. 아이피주소가 문자열의 형태로 오는것을 알고 배열과 포인터 변수를 사용하여 아이피주소를 저장 시키려고 시도했지만. 문자열을 변수에 “=”을 사용해서 저장하려고 하니 기존에 저장되어있던 아이피주소가 새로운 아이피주소로 계속 덮어씌어지는 현상이 발생하였다.  
>2. IP주소는 문자열이여서 전송받는데 큰 어려움이 없었다. 또 accept시 두번째 인자에 아이피주소가 오는것을 확인하고 이를 바로 저장시키면 되었기에 문제가 없었다. 하지만 포트번호는 클라이언트에서 #define 되어있는 값이었다. 이를 클라이언트에서 전송하여 서버에서 저장받고 값을 확인하면 계속 엉뚱한 값이 출력되었다.  
>3. 유저가 파일요청을 어떤유저에게 보내는지에 대한 구별을 하는 과정을 추가하지 않아 기존 Proj#2의 방식대로 메시지를 전송하면 에러가 뜨거나 엉뚱한 유저에게 파일요청을 하는 등의 문제가 발생하였다.  

## 4. 해결방안
>1. 이는 strcpy()를 사용하여 변수에 문자열을 저장시킴으로써 해결되었다. 이 문제를 해결하면서 각 유저의 정보를 담고있는 구조체를 만들어 더욱 직관적이고 코딩할때 편하게 하였다.  
>2. 이를 해결하기 위해 먼저 int형으로 포트번호를 선언하여 send하였다. 하지만 검색결과 intger형의 변수를 send할시 send(sockfd, (void *)변수, .....)와 같이 형을 바꾸어 전송하고 받을때도 이러한 과정을 거쳐야 하는것을 확인하고 시도해보았지만 완벽히 해결이 되지않았다.
따라서 포트번호는 #define을 사용하여 하나의 클라이언트 파일로 여러 아이피 주소에서 어떤 유저가 접속하여도 작동이 되도록 설계하였다.   
>3. 이를 위하여 서버에서 유저 구조체를 만들어 각각의 유저정보를 입력할때 소켓번호도 저장하였다. 이후 세명의 유저가 파일요청을 할수있는 모든 경우의 수에 대하여 조건문을 걸어서 각각 저장된 소켓번호를 사용하여 통신 할 수 있도록 하였다.  

## 5. Flow Chart
>![1](https://user-images.githubusercontent.com/82483513/119313038-0807ea80-bcae-11eb-9291-bae6fc3388ed.png)
>파일요청 메세지를 입력한쪽이 서버가되고 수신받은쪽이 클라이언트가된다. 수신 받은쪽은 요청한 클라이언트의 아이피주소를 받아 서버가 된쪽에 connect()를 한다. 이후 파일전송 프로세스를 진행할 수 있다.  

## 6. server.c 코드 설명
>![1](https://user-images.githubusercontent.com/82483513/119313341-659c3700-bcae-11eb-9b4c-a2c0c4e9b119.png)
>서버 코드에서 3명분의 아이디와 패스워드를 정의하였고 P2P파일전송시 사용할 매크로 변수를 선언하였다. 11~18라인의 구조체는 로그인시 user의 아이피 및 정보를 각각의 구조체에 입력시킬 수 있도록 선언하였다.
소켓번호가 저장될 client변수는 main함수 의외에서도 사용이 용이하게 전역변수로 선언해주었다.  
>SEND_IP()는 후술.
>![1](https://user-images.githubusercontent.com/82483513/119313410-7a78ca80-bcae-11eb-881c-fb835f0c63c6.png)
>뒤에서 select()함수를 사용하기 위해 구조체 fd_set을 선언하였다.  
>Project#2와 바뀐점으로는 63라인에 클라이언트의 아이피를 문자열의 형태로 임시로 저장할 포인터 변수를 선언하였고 70라인의 로그인의 실패여부를 알려주는 변수를 선언하였다.
여기서 login_fail_flag의 값이 1이되면 로그인에 실패하였다는 의미이다.  
>![1](https://user-images.githubusercontent.com/82483513/119313629-bca20c00-bcae-11eb-90a9-a83ea8319cc1.png)
>![2](https://user-images.githubusercontent.com/82483513/119313650-c3308380-bcae-11eb-8f0e-baaa9be2ae77.png)
>모든 문자열을 recv받을때에는 받은 문자열의 끝에 '\0'을 추가해줌으로써 출력이 정상적으로 되게 한다.  

  


## 7. client.c 코드 설명
